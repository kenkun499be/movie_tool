<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>動画再生アドオンツール</title>
  <link rel="stylesheet" href="style.css" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <h1>動画再生アドオンツール</h1>

  <label for="addonName">アドオン名:</label>
  <input type="text" id="addonName" placeholder="例: MyVideoAddon" />

  <p class="notice">
    ⚠️ <strong>注意事項</strong><br>
    ・<strong>15秒を超える動画は先頭15秒だけ処理</strong>されます。<br>
    ・動画の解像度は<strong>854×480にしてください</strong>。それ以外は中央854×480に切り抜かれます。
  </p>

  <input type="file" id="videoInput" accept="video/*" />
  <div id="loopToggleContainer">
    <label for="loopToggle">ループ再生:</label>
    <input type="checkbox" id="loopToggle" checked />
  </div>
  <button id="processBtn">処理開始</button>

  <div id="progress-container">
    <progress id="progressBar" value="0" max="100"></progress>
    <span id="progressText">0 / 0 フレーム</span>
  </div>

  <div id="downloads"></div>

  <canvas id="canvas" style="display:none;"></canvas>
  <video id="hiddenVideo" style="display:none;"></video>

  <script src="https://cdn.jsdelivr.net/npm/@zip.js/zip.js@2.7.52/dist/zip.min.js"></script>
  <script>
const FRAME_WIDTH = 854;
const FRAME_HEIGHT = 480;
const FRAME_INTERVAL = 0.1;
const MAX_DURATION = 15;

const videoInput = document.getElementById("videoInput");
const processBtn = document.getElementById("processBtn");
const progressBar = document.getElementById("progressBar");
const progressText = document.getElementById("progressText");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const downloads = document.getElementById("downloads");
const video = document.getElementById("hiddenVideo");
const loopToggle = document.getElementById("loopToggle");
const nameInput = document.getElementById("addonName");

processBtn.addEventListener("click", async () => {
  const file = videoInput.files[0];
  if (!file) return alert("動画ファイルを選んでください");

  downloads.innerHTML = "";
  const url = URL.createObjectURL(file);
  video.src = url;
  await video.play();
  video.pause();

  const loopEnabled = loopToggle.checked;
  const duration = Math.min(video.duration, MAX_DURATION);
  const totalFrames = Math.floor(duration / FRAME_INTERVAL);
  const framesPerRow = Math.floor(8192 / FRAME_WIDTH);
  let rows = Math.ceil(totalFrames / framesPerRow);
  if (!loopEnabled && totalFrames % framesPerRow === 0) rows++;

  canvas.width = framesPerRow * FRAME_WIDTH;
  canvas.height = rows * FRAME_HEIGHT;

  const frames = [];

  for (let i = 0; i < totalFrames; i++) {
    video.currentTime = i * FRAME_INTERVAL;
    await waitForSeek(video);

    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = FRAME_WIDTH;
    tempCanvas.height = FRAME_HEIGHT;
    const tempCtx = tempCanvas.getContext("2d");

    const sx = Math.max(0, (video.videoWidth - FRAME_WIDTH) / 2);
    const sy = Math.max(0, (video.videoHeight - FRAME_HEIGHT) / 2);
    tempCtx.drawImage(video, sx, sy, FRAME_WIDTH, FRAME_HEIGHT, 0, 0, FRAME_WIDTH, FRAME_HEIGHT);

    const x = (i % framesPerRow) * FRAME_WIDTH;
    const y = Math.floor(i / framesPerRow) * FRAME_HEIGHT;
    ctx.drawImage(tempCanvas, 0, 0, FRAME_WIDTH, FRAME_HEIGHT, x, y, FRAME_WIDTH, FRAME_HEIGHT);

    frames.push({
      filename: `frame-${i}.ase`,
      frame: { x, y, w: FRAME_WIDTH, h: FRAME_HEIGHT },
      rotated: false,
      trimmed: false,
      spriteSourceSize: { x: 0, y: 0, w: FRAME_WIDTH, h: FRAME_HEIGHT },
      sourceSize: { w: FRAME_WIDTH, h: FRAME_HEIGHT },
      duration: 100
    });

    progressBar.value = i + 1;
    progressText.textContent = `${i + 1} / ${totalFrames} フレーム`;
  }

  if (!loopEnabled) {
    const x = (totalFrames % framesPerRow) * FRAME_WIDTH;
    const y = Math.floor(totalFrames / framesPerRow) * FRAME_HEIGHT;
    ctx.fillStyle = "black";
    ctx.fillRect(x, y, FRAME_WIDTH, FRAME_HEIGHT);
    frames.push({
      filename: `frame-${totalFrames}.ase`,
      frame: { x, y, w: FRAME_WIDTH, h: FRAME_HEIGHT },
      rotated: false,
      trimmed: false,
      spriteSourceSize: { x: 0, y: 0, w: FRAME_WIDTH, h: FRAME_HEIGHT },
      sourceSize: { w: FRAME_WIDTH, h: FRAME_HEIGHT },
      duration: 3600000
    });
  }

  canvas.toBlob(async blob => {
    const png = new File([blob], "textures/ui/movie.png");
    const json = new File([
      JSON.stringify({
        frames,
        meta: {
          app: "動画再生アドオンツール",
          image: "movie.png",
          size: { w: canvas.width, h: canvas.height },
          scale: "1"
        }
      }, null, 2)
    ], "textures/ui/movie.json", { type: "application/json" });

    const manifest = new File([
      JSON.stringify({
        format_version: 2,
        header: {
          name: nameInput.value || "MyAddon",
          description: "Video playback UI",
          uuid: crypto.randomUUID(),
          version: [1, 0, 0],
          min_engine_version: [1, 20, 0]
        },
        modules: [{
          type: "resources",
          uuid: crypto.randomUUID(),
          version: [1, 0, 0]
        }]
      }, null, 2)
    ], "manifest.json", { type: "application/json" });

    const serverForm = new File([
      await fetch("server_form.json").then(r => r.text())
    ], "ui/server_form.json", { type: "application/json" });

    const zipBlob = await createZip([
      ["textures/ui/movie.png", png],
      ["textures/ui/movie.json", json],
      ["manifest.json", manifest],
      ["ui/server_form.json", serverForm]
    ]);

    const name = sanitizeFileName(nameInput.value || "MyAddon");
    const zipUrl = URL.createObjectURL(zipBlob);
    addDownload(zipUrl, `${name}.mcpack`);
  }, "image/png");
});

function waitForSeek(video) {
  return new Promise(resolve => {
    const handler = () => {
      video.removeEventListener("seeked", handler);
      resolve();
    };
    video.addEventListener("seeked", handler);
  });
}

function addDownload(url, name) {
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  a.textContent = `${name} をダウンロード`;
  downloads.appendChild(a);
}

function sanitizeFileName(name) {
  return name.replace(/[\\/:*?"<>|]/g, "_");
}

async function createZip(entries) {
  const zipWriter = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
  for (const [path, file] of entries) {
    await zipWriter.add(path, new zip.BlobReader(file));
  }
  return zipWriter.close();
}
  </script>
  
</body>
</html>
